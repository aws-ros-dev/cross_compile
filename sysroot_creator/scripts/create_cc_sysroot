#!/usr/bin/env python3

import argparse
from pathlib import Path


class Platform:
    def __init__(self, arch, os, distro, rmw):
        self.arch = arch
        self.os = os
        self.distro = distro
        self.rmw = rmw

    def __str__(self):
        return '-'.join((self.arch, self.os, self.rmw, self.distro))



class CCSetupSysrootVerb(VerbExtensionPoint):
    """Setup a sysroot for cross-compiling ROS 2 packages."""

    def __init__(self):
        super().__init__()
        self._wd = Path.cwd()
        satisfies_version(VerbExtensionPoint.EXTENSION_POINT_VERSION, '^1.0')
        self._docker_client = docker.from_env()
        self._platform_info = None

    @classmethod
    def _print_docker_logs(cls, logs):
        for stream_obj in logs:
            for line in stream_obj.get('stream', '').split('\n'):
                print('{}'.format(line))

    def _build_workspace_sysroot_image(self, *, context, workspace_image_tag):
        print('Fetching sysroot base image {}'.format(context.args.sysroot_base_image))
        self._docker_client.images.pull(context.args.sysroot_base_image)
        # FIXME consider moving constants to static fields
        workspace_dockerfile_path = (Path(__file__).parent / 'sysroot' / 'Dockerfile_workspace')
        buildargs = {
            'ROS2_BASE_IMG': context.args.sysroot_base_image,
            'ROS2_WORKSPACE': '.',
            'ROS_DISTRO': context.args.distro,
            'TARGET_TRIPLE': self._platform_info['target_triple']
        }
        print('Building workspace image {} (this might take some time...)'.format(
            workspace_image_tag))
        # FIXME: this gives no output until the whole image is built,
        # at least implement some spinner
        try:
            _workspace_image, _ws_image_build_logs = self._docker_client.images.build(
                path='.',
                dockerfile=str(workspace_dockerfile_path),
                tag=workspace_image_tag,
                buildargs=buildargs,
                quiet=False,
                nocache=context.args.sysroot_nocache,
                network_mode=context.args.docker_network_mode)
            print('Docker build output')
            self._print_docker_logs(_ws_image_build_logs)
            print()
        except docker.errors.BuildError as be:
            print('Error building sysroot image')
            print('\tError message: {}'.format(be.msg))
            print('\tBuild log')
            self._print_docker_logs(be.build_log)
            print()
            raise be

    def _setup_workspace_sysroot(self, *, context):
        """
        Set up a sysroot for a workspace.

        :return: a Path object for the directory where the workspace sysroot is located
        """
        cc_root = _get_cc_root(wd=self._wd, context=context)
        target_sysroot_path = cc_root / 'sysroot'
        if not context.args.force_sysroot_build and target_sysroot_path.exists():
            print('Using existing sysroot path [{}]'.format(target_sysroot_path))
        else:
            if not target_sysroot_path.exists():
                print('No sysroot found at path [{}], building it now'.format(target_sysroot_path))
            elif context.args.force_sysroot_build:
                print('Forced sysroot re-build')
            workspace_image_tag = self._get_workspace_sysroot_image(context=context)
            self._export_workspace_sysroot_image(
                context=context,
                workspace_image_tag=workspace_image_tag,
                target_sysroot_path=target_sysroot_path)
        return target_sysroot_path

    def _export_workspace_sysroot_image(
        self, *, context, workspace_image_tag, target_sysroot_path
    ):
        print('Exporting sysroot to path [{}]'.format(target_sysroot_path))
        shutil.rmtree(str(target_sysroot_path), ignore_errors=True)
        tmp_sysroot_dir = tempfile.mkdtemp(suffix='-cc_build')
        sysroot_tarball_path = Path(tmp_sysroot_dir) / 'sysroot.tar'
        print('Exporting filesystem of image {} into tarball {}'.format(
            workspace_image_tag, sysroot_tarball_path))
        try:
            sysroot_container = self._docker_client.containers.run(
                image=workspace_image_tag, detach=True)
            with open(str(sysroot_tarball_path), 'wb') as out_f:
                out_f.writelines(sysroot_container.export())
            sysroot_container.stop()
            with tarfile.open(str(sysroot_tarball_path)) as sysroot_tar:
                relevant_dirs = ['lib', 'usr', 'etc', 'opt', 'root_path']
                relevant_members = (
                    m for m in sysroot_tar.getmembers()
                    if re.match('^({}).*'.format('|'.join(relevant_dirs)), m.name) is not None)
                sysroot_tar.extractall(str(target_sysroot_path), members=relevant_members)
        finally:
            shutil.rmtree(tmp_sysroot_dir, ignore_errors=True)
        print('Success exporting sysroot to path [{}]'.format(target_sysroot_path))

    def _write_cc_build_setup_file(self, *, cc_root, context):
        cc_build_setup_file_path = cc_root / 'cc_build_setup.bash'
        cc_build_setup_file_contents = _CC_BUILD_SETUP_FILE_TEMPLATE.format(
            ros_root='{cc_root}/sysroot/opt/ros/{distro}'.format(
              cc_root=cc_root, distro=context.args.distro),
            target_arch=self._platform_info['target_arch'],
            target_triple=self._platform_info['target_triple'],
            cc_root=cc_root)
        with open(str(cc_build_setup_file_path), 'w') as out_f:
            out_f.write(cc_build_setup_file_contents)
        return cc_build_setup_file_path

    def _write_cc_system_setup_script(self, *, cc_root):
        cc_system_setup_script_path = cc_root / 'cc_system_setup.bash'
        cc_system_setup_script_contents = _CC_BUILD_SYSTEM_SETUP_SCRIPT_TEMPLATE.format(
            cc_root=cc_root,
            target_triple=self._platform_info['target_triple']
        )
        with open(str(cc_system_setup_script_path), 'w') as out_f:
            out_f.write(cc_system_setup_script_contents)
        return cc_system_setup_script_path

    def main(self, *, context):
        self._setup_workspace_sysroot(context=context)
        cc_build_setup_file_path = self._write_cc_build_setup_file(
          cc_root=cc_root, context=context)
        # generalization of the Poco hack
        # from https://github.com/ros2/cross_compile/blob/master/entry_point.sh#L38
        cc_system_setup_script_path = self._write_cc_system_setup_script(cc_root=cc_root)
        print("""

In order to complete the cross compilation setup, please

1. WORKAROUND: run the command below to setup using sysroot's GLIBC for cross compilation.

    bash {cc_system_setup_script_path}

2. Run

    source {cc_build_setup_file_path}

to setup the cross compilation build environment

""".format(cc_system_setup_script_path=cc_system_setup_script_path,
           cc_build_setup_file_path=cc_build_setup_file_path))
        return 0


def log(*args, **kwargs):
    print(*args, **kwargs)


def setup_workspace_sysroot(platform: Platform, force_sysroot_build: bool) -> Path:
    cc_root = Path.cwd() / str(platform)
    cc_root.mkdir(parents=True, exist_ok=True)
    (cc_root / 'COLCON_IGNORE').touch()
    target_sysroot = cc_root / 'sysroot'

    if not force_sysroot_build and target_sysroot.exists():
        log('Using existing sysroot found at: {}'.format(target_sysroot))
        return
    if target_sysroot.exists():
        log('Found sysroot - forcing rebuild.')
    else:
        log('Sysroot not found, building now.')

    workspace_image_tag = Path.cwd().name + ':latest'
    _build_workspace_sysroot_image(workspace_image_tag=workspace_image_tag)
    log('Successfully created sysroot docker image: {}'.format(workspace_image_tag))

    _export_workspace_sysroot_image(
        context=context,
        workspace_image_tag=workspace_image_tag,
        target_sysroot_path=target_sysroot_path)

    return target_sysroot



def create_arg_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--arch',
        required=True,
        type=str,
        help='Target architecture')
    parser.add_argument(
        '--os',
        required=True,
        type=str,
        help='Target OS')
    parser.add_argument(
        '--distro',
        required=False,
        type=str,
        default='crystal',
        help='Target ROS distribution')
    parser.add_argument(
        '--rmw',
        required=False,
        type=str,
        default='fastrtps',
        help='Target RMW implementation')
    parser.add_argument(
        '--sysroot-base-image',
        type=str,
        help='Base image to use for building the sysroot')
    parser.add_argument(
        '--docker-network-mode',
        type=str,
        default='host',
        help="Docker's network_mode parameter to use for all Docker interactions")
    parser.add_argument(
        '--sysroot-nocache',
        type=bool,
        default=False,
        help="When set to true, this disables Docker's cache when building the image for the"
             'workspace sysroot')
    parser.add_argument(
        '--force-sysroot-build',
        type=bool,
        default=False,
        help='When set to true, we rebuild the sysroot and sysroot image, '
             'even if any of those is availble')
    return parser


def main():
    parser = create_arg_parser()
    args = parser.parse_args()
    platform = Platform(args.arch, args.os, args.distro, args.rmw)
    sysroot = setup_workspace_sysroot(platform)
    cc_build_setup_file_path =


if __name__ == '__main__':
    main()
