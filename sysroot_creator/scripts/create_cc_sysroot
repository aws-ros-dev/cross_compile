#!/usr/bin/env python3

"""Script to generate sysroot for cross-compiling ROS2."""

import argparse
import os
import re
import shutil
import sys
import tarfile
import tempfile
import threading
import time
from pathlib import Path

import docker
from docker import APIClient
from tqdm import tqdm
import jinja2


CC_BUILD_SETUP_FILE_TEMPLATE = jinja2.Template("""
if [ -d {{ros_root}} ]
then
    source {{ros_root}}/setup.bash
else
    echo "WARNING: no ROS distro found on the sysroot"
fi

export TARGET_ARCH={{target_arch}}
export TARGET_TRIPLE={{target_triple}}
export CC_ROOT={{cc_root}}
""")  # noqa

CC_BUILD_SYSTEM_SETUP_SCRIPT_TEMPLATE = jinja2.Template("""
sudo rm -rf /lib/{{target_triple}}
sudo ln -s {{cc_root}}/sysroot/lib/{{target_triple}} /lib/{{target_triple}}
sudo rm -rf /usr/lib/{{target_triple}}
sudo ln -s {{cc_root}}/sysroot/usr/lib/{{target_triple}} /usr/lib/{{target_triple}}

CROSS_COMPILER_LIB=/usr/{{target_triple}}/lib
CROSS_COMPILER_LIB_BAK=$CROSS_COMPILER_LIB_$(date +%s).bak
echo "Backing up $CROSS_COMPILER_LIB to $CROSS_COMPILER_LIB_BAK"
sudo mv $CROSS_COMPILER_LIB $CROSS_COMPILER_LIB_BAK
sudo ln -s {{cc_root}}/sysroot/lib/{{target_triple}} $CROSS_COMPILER_LIB
""")  # noqa

SYSROOT_DIR_NAME: str = 'sysroot'
DOCKER_WS_NAME: str = 'Dockerfile_workspace'
DOCKER_CLIENT = docker.from_env()


class Platform:
    """A class that represents platform specification for cross compiling.

    Includes:
    1. Target architecture
    2. Target operating system
    3. ROS2 distribution used
    4. RMW implementation used
    """

    def __init__(self, arch, os, distro, rmw):
        self.arch = arch
        self.os = os
        self.distro = distro
        self.rmw = rmw

        if self.arch == 'armhf':
            self.cc_toolchain = 'arm-linux-gnueabihf'
        elif self.arch == 'aarch64':
            self.cc_toolchain = 'aarch64-linux-gnu'

    def __str__(self):
        return '-'.join((self.arch, self.os, self.rmw, self.distro))


class DockerConfig:
    """
    A class that represents docker build parameters used in creating sysroot.

    Includes:
    1. Base docker image to use for building sysroot
    2. Docker network mode
    3. Setting to enable/disable caching during docker build
    """

    def __init__(self, base_image, network_mode, nocache, ros2_workspace):
        self.base_image = base_image
        self.network_mode = network_mode
        self.nocache = nocache
        self.ros2_workspace = ros2_workspace


def log(*args, **kwargs):
    print(*args, **kwargs)


def print_docker_logs(logs):
    for stream_obj in logs:
        for line in stream_obj.get('stream', '').split('\n'):
            log('{}'.format(line))


def setup_cc_root_dir(platform: Platform) -> Path:
    log('Creating workspace directory')
    cc_root = Path.cwd() / str(platform)
    cc_root.mkdir(parents=True, exist_ok=True)
    (cc_root / 'COLCON_IGNORE').touch()
    return cc_root


def setup_sysroot_dir(cc_root_dir: Path, force_sysroot_build: bool) -> Path:
    log('Creating sysroot directory')
    target_sysroot = cc_root_dir / SYSROOT_DIR_NAME

    if target_sysroot.exists():
        if not force_sysroot_build:
            log('Using existing sysroot found at: {}'.format(target_sysroot))
        else:
            log('Sysroot exists - forcing rebuild')
    else:
        log('Sysroot not found, building now')
        os.makedirs(str(target_sysroot))

    return target_sysroot


def get_workspace_image_tag(platform: Platform) -> str:
    return os.getenv('USER') + '/' + platform.__str__() + ':latest'


def build_workspace_sysroot_image(
        platform: Platform,
        docker_args: DockerConfig,
        image_tag: str):
    log('Fetching sysroot base image {}'.format(docker_args.base_image))
    DOCKER_CLIENT.images.pull(docker_args.base_image)
    # FIXME consider moving constants to static fields
    workspace_dockerfile_path = (Path(__file__).parent / SYSROOT_DIR_NAME /
                                 DOCKER_WS_NAME)

    buildargs = {
        'ROS2_BASE_IMG': docker_args.base_image,
        'ROS2_WORKSPACE': './' + SYSROOT_DIR_NAME,
        'ROS_DISTRO': platform.distro,
        'TARGET_TRIPLE': platform.cc_toolchain
    }
    log('Building workspace image {} (this might take some time...)'
        .format(image_tag))

    try:
        docker_client = docker.APIClient(base_url='unix://var/run/docker.sock')
        log_generator = docker_client.build(
            path='.',
            dockerfile=str(workspace_dockerfile_path),
            tag=image_tag,
            buildargs=buildargs,
            quiet=False,
            nocache=docker_args.nocache,
            network_mode=docker_args.network_mode,
            decode=True)
        with tqdm(log_generator) as t:
            for chunk in t:
                try:
                    line = chunk['stream'].rstrip().lstrip()
                    if line == '':
                        continue
                    t.set_postfix_str(line)
                except (KeyError, AttributeError) as e:
                    print("Error reading the Dockerfile image. The following exception"
                          "was caught:\n{}".format(e))
                    sys.exit(0)
    except docker.errors.BuildError as be:
        print('Error building sysroot image')
        print('\tError message: {}'.format(be.msg))
        print('\tBuild log')
        print_docker_logs(be.build_log)
        print()
        raise be

    log('Successfully created sysroot docker image: {}'.format(image_tag))


def export_workspace_sysroot_image(image_tag, target_sysroot_path):
    log('Exporting sysroot to path [{}]'.format(target_sysroot_path))
    shutil.rmtree(str(target_sysroot_path), ignore_errors=True)
    tmp_sysroot_dir = tempfile.mkdtemp(suffix='-cc_build')
    sysroot_tarball_path = Path(tmp_sysroot_dir) / (SYSROOT_DIR_NAME + '.tar')
    log('Exporting filesystem of image {} into tarball {}'.format(
        image_tag, sysroot_tarball_path))
    try:
        sysroot_container = DOCKER_CLIENT.containers.run(
            image=image_tag, detach=True)
        with open(str(sysroot_tarball_path), 'wb') as out_f:
            out_f.writelines(sysroot_container.export())
        sysroot_container.stop()
        with tarfile.open(str(sysroot_tarball_path)) as sysroot_tar:
            relevant_dirs = ['lib', 'usr', 'etc', 'opt', 'root_path']
            relevant_members = (
                m for m in sysroot_tar.getmembers()
                if re.match('^({}).*'.format('|'.join(relevant_dirs)), m.name)
                is not None)
            sysroot_tar.extractall(str(target_sysroot_path),
                                   members=relevant_members)
    finally:
        shutil.rmtree(tmp_sysroot_dir, ignore_errors=True)
    log('Success exporting sysroot to path [{}]'.format(target_sysroot_path))


def write_cc_build_setup_file(platform: Platform, cc_root_dir: Path):
    cc_build_setup_file_path = cc_root_dir / 'cc_build_setup.bash'
    cc_build_setup_file_contents = CC_BUILD_SETUP_FILE_TEMPLATE.render(
        ros_root='{cc_root_dir}/sysroot/opt/ros/{distro}'.format(
            cc_root_dir=cc_root_dir, distro=platform.distro),
        target_arch=platform.arch,
        target_triple=platform.cc_toolchain,
        cc_root=cc_root_dir)
    with open(str(cc_build_setup_file_path), 'w') as out_f:
        out_f.write(cc_build_setup_file_contents)
    return cc_build_setup_file_path


def write_cc_system_setup_script(cc_root_dir: Path, platform: Platform):
    cc_system_setup_script_path = cc_root_dir / 'cc_system_setup.bash'
    cc_system_setup_script_contents = \
        CC_BUILD_SYSTEM_SETUP_SCRIPT_TEMPLATE.render(
            cc_root=cc_root_dir,
            target_triple=platform.cc_toolchain
        )
    with open(str(cc_system_setup_script_path), 'w') as out_f:
        out_f.write(cc_system_setup_script_contents)
    return cc_system_setup_script_path


def create_arg_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--arch',
        required=True,
        type=str,
        help='Target architecture')
    parser.add_argument(
        '--os',
        required=True,
        type=str,
        help='Target OS')
    parser.add_argument(
        '--distro',
        required=False,
        type=str,
        default='dashing',
        help='Target ROS distribution')
    parser.add_argument(
        '--rmw',
        required=False,
        type=str,
        default='fastrtps',
        help='Target RMW implementation')
    parser.add_argument(
        '--sysroot-base-image',
        type=str,
        help='Base image to use for building the sysroot')
    parser.add_argument(
        '--docker-network-mode',
        type=str,
        default='host',
        help="Docker's network_mode parameter to use for all "
             'Docker interactions')
    parser.add_argument(
        '--sysroot-nocache',
        type=bool,
        default=False,
        help="When set to true, this disables Docker's cache when building "
             'the image for the workspace sysroot')
    parser.add_argument(
        '--force-sysroot-build',
        type=bool,
        default=False,
        help='When set to true, we rebuild the sysroot and sysroot image, '
             'even if any of those is available')
    parser.add_argument(
        '--ros2-workspace',
        type=str,
        default='~/ros2_ws',
        help='The location of your ROS2 workspace. Usually ~/ros2_ws.')
    return parser


def main():
    # Configuration
    parser = create_arg_parser()
    args = parser.parse_args()
    platform = Platform(args.arch, args.os, args.distro, args.rmw)
    docker_args = DockerConfig(
        args.sysroot_base_image,
        args.docker_network_mode,
        args.sysroot_nocache,
        args.ros2_workspace)

    # Main pipeline
    cc_root_dir = setup_cc_root_dir(platform)
    sysroot_dir = setup_sysroot_dir(cc_root_dir, args.force_sysroot_build)
    docker_image_tag = get_workspace_image_tag(platform)
    build_workspace_sysroot_image(platform, docker_args, docker_image_tag)
    export_workspace_sysroot_image(docker_image_tag, sysroot_dir)
    cc_build_setup_file_path = write_cc_build_setup_file(platform, cc_root_dir)
    # generalization of the Poco hack
    # from https://github.com/ros2/cross_compile/blob/master/entry_point.sh#L38
    cc_system_setup_script_path = write_cc_system_setup_script(
        cc_root_dir, platform)

    print("""

    In order to complete the cross compilation setup, please

    1. WORKAROUND: run the command below to setup using sysroot's GLIBC for
    cross compilation.

       bash {cc_system_setup_script_path}

    2. Run

       source {cc_build_setup_file_path}

    to setup the cross compilation build environment

    """.format(cc_system_setup_script_path=cc_system_setup_script_path,
               cc_build_setup_file_path=cc_build_setup_file_path))


if __name__ == '__main__':
    main()
